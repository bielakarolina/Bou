<!DOCTYPE html>

<html>

<head>
    <title>Bou</title>
    <script type="text/javascript" src="scripts/three.js"></script>
    <script type="text/javascript" src="scripts/jquery-1.9.0.js"></script>
    <script type="text/javascript" src="scripts/stats.js"></script>
    <script type="text/javascript" src="scripts/dat.gui.js"></script>
	<script type="text/javascript" src="scripts/OrbitControls.js"></script>
    <script type="text/javascript" src="scripts/Detector.js"></script>
    <script type="text/javascript" src="scripts/stats.min.js"></script>
    <script type="text/javascript" src="scripts/KeyboardState.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="message"></div>


<div id="Stats-output">
</div>
<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

// once everything is loaded, we run our Three.js stuff.

$(function () {

    var stopMovingLight = false;
    var keyboard = new KeyboardState();
    var clock = new THREE.Clock();
    var stats = initStats();
    var collidableMeshList = [];

    // create a render and set the size
    var renderer = new THREE.WebGLRenderer();

    renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild( renderer.domElement );
    renderer.shadowMapEnabled = true;

    // create a scene, that will hold all our elements such as objects, cameras and lights.
    var scene = new THREE.Scene();

    // create a camera, which defines where we're looking at.
    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

    var controls = new THREE.OrbitControls( camera, renderer.domElement );

    var maxAnisotropy = 5;

    // create the ground plane
    var floorTexture = new THREE.ImageUtils.loadTexture( 'textures/wall1.png' );
    floorTexture.anisotropy = maxAnisotropy;
    floorTexture.wrapS = THREE.RepeatWrapping;
    floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(32,32);
    floorTexture.needsUpdate = true;
    var planeMaterial = new THREE.MeshPhongMaterial({map: floorTexture, side:THREE.DoubleSide})
    var planeGeometry = new THREE.PlaneGeometry(280,280, 20, 20);
    var plane = new THREE.Mesh(planeGeometry, planeMaterial);
   // plane.receiveShadow = true;

    // rotate and position the plane
  //  plane.rotation.x = 0.5 * Math.PI;
   // plane.position.x = 0
    plane.position.y = 0
   // plane.position.z = 0

    // add the plane to the scene
    scene.add(plane);

    var geometry = new THREE.SphereGeometry( 8, 8, 8 );
    var material = new THREE.MeshLambertMaterial( { color: 0x0000ff } );
    mesh = new THREE.Mesh( geometry, material );
    mesh.position.set(4,4,10);
    scene.add(mesh);



    var cubeGeometry = new THREE.CubeGeometry(40, 40, 40);

            var texture = THREE.ImageUtils.loadTexture("textures/wall2.jpg");
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4,4);
            var cubeMaterial = new THREE.MeshPhongMaterial();
            cubeMaterial.map = texture;

  

    var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube.position.x = 120;
    cube.position.y = 120;
    cube.position.z = 20;

    scene.add(cube);
    collidableMeshList.push(cube);


	var cube1 = new THREE.Mesh(cubeGeometry, cubeMaterial);
    cube1.position.x = 120;
    cube1.position.y = 80;
    cube1.position.z = 20;

    scene.add(cube1);
    collidableMeshList.push(cube1);

    var cube2 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube2.position.x = 120;
    cube2.position.y = 0;
    cube2.position.z = 20;

    scene.add(cube2);
    collidableMeshList.push(cube2);


    var cube3 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube3.position.x = 120;
    cube3.position.y = -40;
    cube3.position.z = 20;

    scene.add(cube3);
    collidableMeshList.push(cube3);

    var cube4 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube4.position.x = 120;
    cube4.position.y = -80;
    cube4.position.z = 20;

    scene.add(cube4);
    collidableMeshList.push(cube4);
	
	var cube5 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube5.position.x = 120;
    cube5.position.y = -120;
    cube5.position.z = 20;

    scene.add(cube5);
    collidableMeshList.push(cube5);
	
	var cube6 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube6.position.x = 80;
    cube6.position.y = -120;
    cube6.position.z = 20;

    scene.add(cube6);
    collidableMeshList.push(cube6);
	
	var cube7 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube7.position.x = 40;
    cube7.position.y = -120;
    cube7.position.z = 20;

    scene.add(cube7);
    collidableMeshList.push(cube7);
	
	var cube8 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube8.position.x = -40;
    cube8.position.y = -120;
    cube8.position.z = 20;

    scene.add(cube8);
    collidableMeshList.push(cube8);
	
	var cube9 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube9.position.x = -80;
    cube9.position.y = -120;
    cube9.position.z = 20;

    scene.add(cube9);
    collidableMeshList.push(cube9);

	var cube10 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube10.position.x = -120;
    cube10.position.y = -120;
    cube10.position.z = 20;

    scene.add(cube10);
    collidableMeshList.push(cube10);

	var cube11 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube11.position.x = -120;
    cube11.position.y = -80;
    cube11.position.z = 20;

    scene.add(cube11);
    collidableMeshList.push(cube11);

	var cube12 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube12.position.x = -120;
    cube12.position.y = -40;
    cube12.position.z = 20;

    scene.add(cube12);
    collidableMeshList.push(cube12);

    var cube13 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube13.position.x = -120;
    cube13.position.y = 0;
    cube13.position.z = 20;

    scene.add(cube13);

    var cube14 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube14.position.x = -120;
    cube14.position.y = 40;
    cube14.position.z = 20;

    scene.add(cube14);

    var cube15 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube15.position.x = -120;
    cube15.position.y = 80;
    cube15.position.z = 20;

    scene.add(cube15);

    var cube16 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube16.position.x = -120;
    cube16.position.y = 120;
    cube16.position.z = 20;

    scene.add(cube16);

    var cube17 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube17.position.x = -40;
    cube17.position.y = 120;
    cube17.position.z = 20;

    scene.add(cube17);

    var cube18 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube18.position.x = 0;
    cube18.position.y = 120;
    cube18.position.z = 20;

    scene.add(cube18);

    var cube19 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube19.position.x = 40;
    cube19.position.y = 120;
    cube19.position.z = 20;

    scene.add(cube19);

    var cube20 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube20.position.x = 80;
    cube20.position.y = 120;
    cube20.position.z = 20;

    scene.add(cube20);

    var cube21 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube21.position.x = -80;
    cube21.position.y = 40;
    cube21.position.z = 20;

    scene.add(cube21);

    var cube22 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube22.position.x = -40;
    cube22.position.y = 40;
    cube22.position.z = 20;

    scene.add(cube22);

    var cube23 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube23.position.x = 0;
    cube23.position.y = 40;
    cube23.position.z = 20;

    scene.add(cube23);

    var cube24 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube24.position.x = 40;
    cube24.position.y = 40;
    cube24.position.z = 20;

    scene.add(cube24);

    var cube25 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube25.position.x = 40;
    cube25.position.y = 0;
    cube25.position.z = 20;

    scene.add(cube25);


    var cube26 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube26.position.x = 40;
    cube26.position.y = -40;
    cube26.position.z = 20;

    scene.add(cube26);

    var cube27 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube27.position.x = 0;
    cube27.position.y = -40;
    cube27.position.z = 20;

    scene.add(cube27);

    var cube28 = new THREE.Mesh(cubeGeometry, cubeMaterial);

    cube28.position.x = -40;
    cube28.position.y = -40;
    cube28.position.z = 20;

    scene.add(cube28);



    // position and point the camera to the center of the scene
    camera.position.x = 10;
    camera.position.y = -300;
    camera.position.z = 250;
    camera.lookAt(new THREE.Vector3(10, 0, 0));
    //controls.update();


    // add spotlight for a bit of light
    var spotLight0 = new THREE.SpotLight(0xffffff);
    spotLight0.position.set(0,0,600);
    spotLight0.lookAt(plane);
   // scene.add(spotLight0);

    var pointColor = "#000000";
    var spotLight = new THREE.SpotLight(pointColor);
    spotLight.position.set(0,300,10);
    spotLight.castShadow = true;
    spotLight.shadowCameraNear = 2;
    spotLight.shadowCameraFar = 200;
    spotLight.shadowCameraFov = 130;
    spotLight.target = plane;
    spotLight.distance = 0;

  //  scene.add(spotLight);

    var light = new THREE.DirectionalLight( 0xffffff, 1 );
    light.position = camera.position;
    scene.add(light);

    controls.addEventListener( 'change', light_update ); // wraz ze zmianą kamery, zmienia się oświetlenie


    // add the output of the renderer to the html element
    $("#WebGL-output").append(renderer.domElement);

    // call the render function
    var step = 0;

    // used to determine the switch point for the light animation
    var invert = 1;
    var phase = 0;


    function light_update(){
        light.position.copy( camera.position );
    }

    function render() {
        stats.update();
        requestAnimationFrame(render);
        controls.update();
        renderer.render(scene, camera);
        update();
    }

    render();

    function collisionDetector(distanceX, distanceY){
        var collision=0;
        var originPoint = mesh.position.clone();
        clearText();
        //var newposition= new Three.Vector3(distanceX,distanceY,0);

        for (var vertexIndex = 0; vertexIndex < mesh.geometry.vertices.length; vertexIndex++)
        {
            if(distanceY==0)
                var localVertex = mesh.geometry.vertices[vertexIndex].clone().setX(distanceX);
            else
                var localVertex = mesh.geometry.vertices[vertexIndex].clone().setY(distanceY);
            var globalVertex = localVertex.applyMatrix4( mesh.matrix );
            var directionVector = (globalVertex.sub( mesh.position));

            var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
            var collisionResults = ray.intersectObjects( collidableMeshList );
            if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) {
                appendText(" Hit ");
                return 1;
                //mesh.position=originPoint;

            }
        }
        appendText(" DUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUPPPPPPPPPPPPPPPPPPPPAAAAAAAAAAAAAAAAAA ");
        return 0;
    }

    function update()
    {
        keyboard.update();

        var moveDistance = 50 * clock.getDelta();

        if ( keyboard.down("left"))
            if((collisionDetector(-10,0))==0)
                mesh.translateX( -10 );

        if ( keyboard.down("right") )
            if((collisionDetector(10,0))==0)
                mesh.translateX(  10 );

        if ( keyboard.down("up") )
            if((collisionDetector(0,10))==0)
                mesh.translateY(  10 );

        if ( keyboard.down("down") )
            if((collisionDetector(0,-10))==0)
                mesh.translateY(  -10 );

        if ( keyboard.pressed("A") )
            if((collisionDetector(-moveDistance,0))==0)
                mesh.translateX( -moveDistance );

        if ( keyboard.pressed("D") )
            if((collisionDetector(moveDistance,0))==0)
                mesh.translateX(  moveDistance );

        if ( keyboard.pressed("W"))
            if((collisionDetector(0,moveDistance))==0)
                mesh.translateY(  moveDistance );

        if ( keyboard.pressed("S") )
            if((collisionDetector(0,-moveDistance))==0)
                mesh.translateY(  -moveDistance );

        if ( keyboard.down("R") )
            mesh.material.color = new THREE.Color(0xff0000);
        if ( keyboard.up("R") )
            mesh.material.color = new THREE.Color(0x0000ff);

        controls.update();
        stats.update();
    }


    function clearText()
    {   document.getElementById('message').innerHTML = '..........';   }
    function appendText(txt)
    {   document.getElementById('message').innerHTML += txt;   }



    function initStats() {

        var stats = new Stats();

        stats.setMode(0); // 0: fps, 1: ms

        // Align top-left
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';

        $("#Stats-output").append(stats.domElement);

        return stats;
    }
});


</script>
</body>
</html>


